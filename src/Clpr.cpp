
#include "Clpr.hpp"

#define THRESHOLD_RANGE "threshold_range"

float Clpr::ThresholdParamQuantity::getDisplayValue() {
	float v = getValue();
	if (!module) {
		return v;
	}

	v *= 30.0f;
	v -= 24.0f;
	v *= dynamic_cast<Clpr*>(module)->_thresholdRange;
	return v;
}

void Clpr::ThresholdParamQuantity::setDisplayValue(float v) {
	if (!module) {
		return;
	}
	Clpr* m = dynamic_cast<Clpr*>(module);
	v /= m->_thresholdRange;
	v = clamp(v, -24.0f, 6.0f);
	v += 24.0f;
	v /= 30.0f;
	setValue(v);
}

json_t* Clpr::toJson(json_t* root) {
	json_object_set_new(root, THRESHOLD_RANGE, json_real(_thresholdRange));
	return root;
}

void Clpr::fromJson(json_t* root) {
	json_t* tr = json_object_get(root, THRESHOLD_RANGE);
	if (tr) {
		_thresholdRange = std::max(0.0f, (float)json_real_value(tr));
	}
}

bool Clpr::active() {
	return outputs[LEFT_OUTPUT].isConnected() || outputs[RIGHT_OUTPUT].isConnected();
}

int Clpr::channels() {
	return inputs[LEFT_INPUT].getChannels();
}

void Clpr::addChannel(int c) {
	_engines[c] = new Engine();
}

void Clpr::removeChannel(int c) {
	delete _engines[c];
	_engines[c] = NULL;
}

void Clpr::modulate() {
	_softKnee = params[KNEE_PARAM].getValue() > 0.5f;
}

void Clpr::modulateChannel(int c) {
	Engine& e = *_engines[c];

	e.thresholdDb = params[THRESHOLD_PARAM].getValue();
	if (inputs[THRESHOLD_INPUT].isConnected()) {
		e.thresholdDb *= clamp(inputs[THRESHOLD_INPUT].getPolyVoltage(c) / 10.0f, 0.0f, 1.0f);
	}
	e.thresholdDb *= 30.0f;
	e.thresholdDb -= 24.0f;
	e.thresholdDb *= _thresholdRange;

	float outGain = params[OUTPUT_GAIN_PARAM].getValue();
	if (inputs[OUTPUT_GAIN_INPUT].isConnected()) {
		outGain = clamp(outGain + inputs[OUTPUT_GAIN_INPUT].getPolyVoltage(c) / 5.0f, 0.0f, 1.0f);
	}
	outGain *= 24.0f;
	if (e.outGain != outGain) {
		e.outGain = outGain;
		e.outLevel = decibelsToAmplitude(e.outGain);
	}
}

void Clpr::processChannel(const ProcessArgs& args, int c) {
	Engine& e = *_engines[c];

	float leftInput = inputs[LEFT_INPUT].getPolyVoltage(c);
	float rightInput = inputs[RIGHT_INPUT].getPolyVoltage(c);
	float env = fabsf(leftInput + rightInput);
	float detectorDb = amplitudeToDecibels(env / 5.0f);
	float compressionDb = e.compressor.compressionDb(detectorDb, e.thresholdDb, Compressor::maxEffectiveRatio, _softKnee);
	e.amplifier.setLevel(-compressionDb);
	if (outputs[LEFT_OUTPUT].isConnected()) {
		outputs[LEFT_OUTPUT].setChannels(_channels);
		outputs[LEFT_OUTPUT].setVoltage(e.saturator.next(e.amplifier.next(leftInput) * e.outLevel), c);
	}
	if (outputs[RIGHT_OUTPUT].isConnected()) {
		outputs[RIGHT_OUTPUT].setChannels(_channels);
		outputs[RIGHT_OUTPUT].setVoltage(e.saturator.next(e.amplifier.next(rightInput) * e.outLevel), c);
	}
}

struct ClprWidget : BGModuleWidget {
	static constexpr int hp = 6;

	ClprWidget(Clpr* module) {
		setModule(module);
		box.size = Vec(RACK_GRID_WIDTH * hp, RACK_GRID_HEIGHT);
		setPanel(box.size, "Clpr");
		createScrews();

		// generated by svg_widgets.rb
		auto thresholdParamPosition = Vec(26.0, 52.0);
		auto outputGainParamPosition = Vec(26.0, 134.0);
		auto kneeParamPosition = Vec(39.5, 199.5);

		auto leftInputPosition = Vec(16.0, 244.0);
		auto rightInputPosition = Vec(50.0, 244.0);
		auto thresholdInputPosition = Vec(16.0, 280.0);
		auto outputGainInputPosition = Vec(50.0, 280.0);

		auto leftOutputPosition = Vec(16.0, 320.0);
		auto rightOutputPosition = Vec(50.0, 320.0);
		// end generated by svg_widgets.rb

		addParam(createParam<Knob38>(thresholdParamPosition, module, Clpr::THRESHOLD_PARAM));
		addParam(createParam<Knob38>(outputGainParamPosition, module, Clpr::OUTPUT_GAIN_PARAM));
		addParam(createParam<SliderSwitch2State14>(kneeParamPosition, module, Clpr::KNEE_PARAM));

		addInput(createInput<Port24>(leftInputPosition, module, Clpr::LEFT_INPUT));
		addInput(createInput<Port24>(rightInputPosition, module, Clpr::RIGHT_INPUT));
		addInput(createInput<Port24>(thresholdInputPosition, module, Clpr::THRESHOLD_INPUT));
		addInput(createInput<Port24>(outputGainInputPosition, module, Clpr::OUTPUT_GAIN_INPUT));

		addOutput(createOutput<Port24>(leftOutputPosition, module, Clpr::LEFT_OUTPUT));
		addOutput(createOutput<Port24>(rightOutputPosition, module, Clpr::RIGHT_OUTPUT));
	}

	void contextMenu(Menu* menu) override {
		auto m = dynamic_cast<Clpr*>(module);
		assert(m);

		OptionsMenuItem* tr = new OptionsMenuItem("Threshold range");
		tr->addItem(OptionMenuItem("1x (-24dB to 6dB)", [m]() { return m->_thresholdRange == 1.0f; }, [m]() { m->_thresholdRange = 1.0f; }));
		tr->addItem(OptionMenuItem("2x (-48dB to 12dB)", [m]() { return m->_thresholdRange == 2.0f; }, [m]() { m->_thresholdRange = 2.0f; }));
		OptionsMenuItem::addToMenu(tr, menu);
	}
};

// FIXME: HACK: remove " (Clipper)" from module name if Rack ever starts using descriptions in module search.  Or adds a "clipper" tag.
Model* modelClpr = bogaudio::createModel<Clpr, ClprWidget>("Bogaudio-Clpr", "CLPR (Clipper)", "Hard clipper and distortion", "Dynamics", "Limiter", "Distortion", "Polyphonic");
